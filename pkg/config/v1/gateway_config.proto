syntax = "proto3";

package config.v1;

import "github.com/rancher/opni/internal/codegen/cli/cli.proto";
import "github.com/rancher/opni/pkg/apis/core/v1/core.proto";
import "github.com/rancher/opni/pkg/plugins/driverutil/types.proto";
import "github.com/rancher/opni/pkg/validation/validate.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";

option go_package      = "github.com/rancher/opni/pkg/config/v1";
option (cli.generator) = {
  generate: true
};

// Gateway configuration management
service GatewayConfig {
  option (cli.command_group) = {
    use: "config"
  };

  rpc GetDefaultConfiguration(driverutil.GetRequest) returns (GatewayConfigSpec) {
    option (cli.command) = {
      use: "get-default"
    };
  }
  rpc SetDefaultConfiguration(SetRequest) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use:         "set-default"
      granularity: EditMessage
    };
  }
  rpc GetConfiguration(driverutil.GetRequest) returns (GatewayConfigSpec) {
    option (cli.command) = {
      use: "get"
    };
  }
  rpc SetConfiguration(SetRequest) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use:         "set"
      granularity: EditMessage
    };
  }
  rpc ResetDefaultConfiguration(google.protobuf.Empty) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use: "reset-default"
    };
  }
  rpc ResetConfiguration(ResetRequest) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use:         "reset"
      granularity: EditMessage
    };
  }
  rpc DryRun(DryRunRequest) returns (DryRunResponse) {
    option (cli.command).skip = true;
  }
  rpc ConfigurationHistory(driverutil.ConfigurationHistoryRequest) returns (HistoryResponse) {
    option (cli.command) = {
      use: "history"
    };
  }
}

message GatewayConfigSpec {
  core.Revision        revision      = 1;
  ServerSpec           server        = 2;
  ManagementServerSpec management    = 3;
  RelayServerSpec      relay         = 4;
  HealthServerSpec     health        = 5;
  DashboardServerSpec  dashboard     = 6;
  StorageSpec          storage       = 7;
  CertsSpec            certs         = 8;
  PluginsSpec          plugins       = 9;
  KeyringSpec          keyring       = 10;
  AgentUpgradesSpec    agentUpgrades = 11;
  RateLimitingSpec     rateLimiting  = 12;
}

message ServerSpec {
  // Address and port to serve the gateway's internal http server on.
  optional string httpListenAddress = 1 [
    (cli.flag) = {default: "0.0.0.0:8080"},
    (buf.validate.field) = {}
  ];
  // Address and port to serve the gateway's external grpc server on.
  optional string grpcListenAddress = 2 [(cli.flag).default = "0.0.0.0:9090"];
}

message ManagementServerSpec {
  // Address and port to serve the management http server on.
  optional string httpListenAddress = 1 [(cli.flag).default = "0.0.0.0:11080"];
  // Address and port to serve the management grpc server on.
  optional string grpcListenAddress = 2 [(cli.flag).default = "0.0.0.0:11090"];
  // The advertise address for the management server. This is the address at
  // which other gateway instances will be able to reach this management server.
  optional string advertiseAddress = 3 [(cli.flag).skip = true];
}

message RelayServerSpec {
  // Address and port to serve the relay grpc server on.
  optional string grpcListenAddress = 4 [(cli.flag).default = "0.0.0.0:11190"];
  // The advertise address for the relay server. This is the address at which
  // other gateway instances will be able to reach this relay server.
  // Configured automatically by the manager if not set.
  optional string advertiseAddress = 5 [(cli.flag).skip = true];
}

message HealthServerSpec {
  // Address and port to serve the gateway's internal health/metrics/profiling
  // http server on.
  optional string httpListenAddress = 1 [(cli.flag).default = "0.0.0.0:8086"];
}

message DashboardServerSpec {
  // Address and port to serve the web dashboard on.
  optional string httpListenAddress = 1 [(cli.flag).default = "0.0.0.0:12080"];
  // The advertise address for the dashboard server.
  optional string advertiseAddress = 2 [(cli.flag).skip = true];
  // The hostname at which the dashboard is expected to be reachable. This is
  // required when using OpenID Connect authentication.
  optional string hostname = 3;
  // List of trusted proxies for the dashboard's http server.
  repeated string trustedProxies = 4;
}

enum StorageType {
  // Use etcd for key-value storage. This is the recommended default.
  Etcd = 0;
  // Use NATS JetStream for key-value storage.
  JetStream = 1;
}

message StorageSpec {
  option (buf.validate.message).cel = {
    id:         "storage_type_configured"
    message:    "selected storage type must have matching configuration set"
    expression: "(this.type == 'Etcd' && this.etcd) || (this.type == 'JetStream' && this.jetstream)"
  };
  optional StorageType type      = 1 [(cli.flag).default = "Etcd"];
  EtcdSpec             etcd      = 2;
  JetStreamSpec        jetstream = 3;
}

message EtcdSpec {
  optional string endpoint = 1;
  MTLSSpec        certs    = 2;
}

message MTLSSpec {
  option (buf.validate.message) = {
    cel: [
      {
        id:         "fields_mutually_exclusive_serverca"
        message:    "fields serverCA and serverCAData are mutually exclusive"
        expression: "!(this.serverCA && this.serverCAData)"
      },
      {
        id:         "fields_mutually_exclusive_clientca"
        message:    "fields clientCA and clientCAData are mutually exclusive"
        expression: "!(this.clientCA && this.clientCAData)"
      },
      {
        id:         "fields_mutually_exclusive_clientcert"
        message:    "fields clientCert and clientCertData are mutually exclusive"
        expression: "!(this.clientCert && this.clientCertData)"
      },
      {
        id:         "fields_mutually_exclusive_clientkey"
        message:    "fields clientKey and clientKeyData are mutually exclusive"
        expression: "!(this.clientKey && this.clientKeyData)"
      }
    ]
  };
  // Path to the server CA certificate. Mutually exclusive with serverCAData.
  optional string serverCA = 1;
  // PEM encoded server CA certificate data. Mutually exclusive with serverCA.
  optional string serverCAData = 2 [(cli.flag).secret = true];
  // Path to the client CA certificate (not needed in all cases). Mutually exclusive with clientCAData.
  optional string clientCA = 3;
  // PEM encoded client CA certificate data. Mutually exclusive with clientCA.
  optional string clientCAData = 4 [(cli.flag).secret = true];
  // Path to the certificate used for client-cert auth. Mutually exclusive with clientCertData.
  optional string clientCert = 5;
  // PEM encoded client certificate data. Mutually exclusive with clientCert.
  optional string clientCertData = 6 [(cli.flag).secret = true];
  // Path to the private key used for client-cert auth. Mutually exclusive with clientKeyData.
  optional string clientKey = 7;
  // PEM encoded client key data. Mutually exclusive with clientKey.
  optional string clientKeyData = 8 [(cli.flag).secret = true];
}

message JetStreamSpec {
  optional string endpoint     = 1;
  optional string nkeySeedPath = 2;
}

message CertsSpec {
  option (buf.validate.message) = {
    cel: [
      {
        id:         "fields_mutually_exclusive_ca"
        message:    "fields caCert and caCertData are mutually exclusive"
        expression: "!(this.caCert && this.caCertData)"
      },
      {
        id:         "fields_mutually_exclusive_servingcert"
        message:    "fields servingCert and servingCertData are mutually exclusive"
        expression: "!(this.servingCert && this.servingCertData)"
      },
      {
        id:         "fields_mutually_exclusive_servingkey"
        message:    "fields servingKey and servingKeyData are mutually exclusive"
        expression: "!(this.servingKey && this.servingKeyData)"
      }
    ]
  };

  // Path to a PEM encoded CA certificate file. Mutually exclusive with caCertData.
  optional string caCert = 1;
  // PEM encoded CA certificate data. Mutually exclusive with caCert.
  optional string caCertData = 2 [(cli.flag).secret = true];
  // Path to a PEM encoded server certificate file. Mutually exclusive with servingCertData.
  optional string servingCert = 3;
  // PEM encoded server certificate data. Mutually exclusive with servingCert.
  optional string servingCertData = 4 [(cli.flag).secret = true];
  // Path to a PEM encoded server key file. Mutually exclusive with servingKeyData.
  optional string servingKey = 5;
  // String containing PEM encoded server key data. Mutually exclusive with servingKey.
  optional string servingKeyData = 6 [(cli.flag).secret = true];
}

message PluginsSpec {
  // Directory to search for plugin binaries.
  optional string dir = 1 [(cli.flag).default = "/var/lib/opni/plugins"];

  CacheSpec cache = 2;
}

enum PatchEngine {
  Bsdiff = 0;
  Zstd   = 1;
}

enum CacheBackend {
  Filesystem = 0;
}

message CacheSpec {
  optional PatchEngine patchEngine = 1 [(cli.flag).default = "Zstd"];

  optional CacheBackend backend    = 2;
  FilesystemCacheSpec   filesystem = 3;
}

message FilesystemCacheSpec {
  optional string dir = 1 [(cli.flag).default = "/var/lib/opni/plugin-cache"];
}

message KeyringSpec {
  // Directories to search for files containing runtime keys.
  // All files in these directories will be loaded into the keyring on
  // startup. Keys loaded in this way will not be persisted.
  repeated string runtimeKeyDirs = 1;
}

message AgentUpgradesSpec {
  KubernetesAgentUpgradeSpec kubernetes = 1;
}

enum ImageResolverType {
  Noop       = 0;
  Kubernetes = 1;
}

message KubernetesAgentUpgradeSpec {
  optional ImageResolverType imageResolver = 1 [(cli.flag).default = "Kubernetes"];
}

message RateLimitingSpec {
  optional double rate  = 1;
  optional int32  burst = 2;
}

message SetRequest {
  GatewayConfigSpec spec = 1;
}

message ResetRequest {
  core.Revision             revision = 1 [(cli.flag_set).no_prefix = true];
  google.protobuf.FieldMask mask     = 2 [(cli.flag).skip = true];
  GatewayConfigSpec         patch    = 3 [(cli.flag).skip = true];
}

message DryRunRequest {
  driverutil.Target target = 1;
  driverutil.Action action = 2;

  GatewayConfigSpec spec = 3; // Set

  core.Revision             revision = 4; // Reset
  GatewayConfigSpec         patch    = 5; // Reset
  google.protobuf.FieldMask mask     = 6 [(cli.flag).skip = true]; // Reset
}

message DryRunResponse {
  GatewayConfigSpec       current          = 1;
  GatewayConfigSpec       modified         = 2;
  buf.validate.Violations validationErrors = 3;
}

message HistoryResponse {
  repeated GatewayConfigSpec entries = 1;
}
