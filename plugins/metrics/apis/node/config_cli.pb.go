// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/plugins/metrics/apis/node/config.proto

package node

import (
	context "context"
	errors "errors"
	cli "github.com/rancher/opni/internal/codegen/cli"
	v1 "github.com/rancher/opni/pkg/apis/core/v1"
	v1beta1 "github.com/rancher/opni/pkg/config/v1beta1"
	cliutil "github.com/rancher/opni/pkg/opni/cliutil"
	driverutil "github.com/rancher/opni/pkg/plugins/driverutil"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type contextKey_NodeConfiguration_type struct{}

var contextKey_NodeConfiguration contextKey_NodeConfiguration_type

func ContextWithNodeConfigurationClient(ctx context.Context, client NodeConfigurationClient) context.Context {
	return context.WithValue(ctx, contextKey_NodeConfiguration, client)
}

func NodeConfigurationClientFromContext(ctx context.Context) (NodeConfigurationClient, bool) {
	client, ok := ctx.Value(contextKey_NodeConfiguration).(NodeConfigurationClient)
	return client, ok
}

var extraCmds_NodeConfiguration []*cobra.Command

func addExtraNodeConfigurationCmd(custom *cobra.Command) {
	extraCmds_NodeConfiguration = append(extraCmds_NodeConfiguration, custom)
}

func BuildNodeConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config",
		Short: `The NodeConfiguration service allows for per-node configuration of the`,
		Long: `
metrics capability.
Served as a management API extension.
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildNodeConfigurationGetDefaultConfigurationCmd(),
		BuildNodeConfigurationSetDefaultConfigurationCmd(),
		BuildNodeConfigurationResetDefaultConfigurationCmd(),
		BuildNodeConfigurationGetConfigurationCmd(),
		BuildNodeConfigurationSetConfigurationCmd(),
		BuildNodeConfigurationResetConfigurationCmd(),
		BuildNodeConfigurationConfigurationHistoryCmd(),
	}, extraCmds_NodeConfiguration...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildNodeConfigurationGetDefaultConfigurationCmd() *cobra.Command {
	in := &driverutil.GetRequest{}
	cmd := &cobra.Command{
		Use:   "config get-default",
		Short: "",
		Long: `
HTTP handlers for this method:
- GET /node_config
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildNodeConfigurationSetDefaultConfigurationCmd() *cobra.Command {
	in := &SetRequest{}
	cmd := &cobra.Command{
		Use:   "config set-default",
		Short: "",
		Long: `
HTTP handlers for this method:
- PUT /node_config
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildNodeConfigurationResetDefaultConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config reset-default",
		Short: "",
		Long: `
HTTP handlers for this method:
- DELETE /node_config
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ResetDefaultConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildNodeConfigurationGetConfigurationCmd() *cobra.Command {
	in := &NodeGetRequest{}
	cmd := &cobra.Command{
		Use:   "config get",
		Short: "",
		Long: `
HTTP handlers for this method:
- GET /node_config/{id}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildNodeConfigurationSetConfigurationCmd() *cobra.Command {
	in := &NodeSetRequest{}
	cmd := &cobra.Command{
		Use:   "config set",
		Short: "",
		Long: `
HTTP handlers for this method:
- PUT /node_config/{node.id}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildNodeConfigurationResetConfigurationCmd() *cobra.Command {
	in := &NodeResetRequest{}
	cmd := &cobra.Command{
		Use:   "config reset",
		Short: "",
		Long: `
HTTP handlers for this method:
- DELETE /node_config/{node.id}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.ResetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildNodeConfigurationConfigurationHistoryCmd() *cobra.Command {
	in := &ConfigurationHistoryRequest{}
	cmd := &cobra.Command{
		Use:   "config history",
		Short: "",
		Long: `
HTTP handlers for this method:
- GET /node_config/{node.id}/history
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := NodeConfigurationClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.ConfigurationHistory(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.RegisterFlagCompletionFunc("target", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"ActiveConfiguration", "DefaultConfiguration"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func (in *SetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Spec == nil {
		in.Spec = &MetricsCapabilityConfig{}
	}
	fs.AddFlagSet(in.Spec.FlagSet(append(prefix, "spec")...))
	return fs
}

func (in *MetricsCapabilityConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("MetricsCapabilityConfig", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(append(prefix, "revision")...))
	if in.Rules == nil {
		in.Rules = &v1beta1.RulesSpec{}
	}
	fs.AddFlagSet(in.Rules.FlagSet(append(prefix, "rules")...))
	flagutil.SetDefValue(fs, strings.Join(append(prefix, "rules", "discovery.prometheus-rules.search-namespaces"), "."), `[""]`)
	fs.Var(flagutil.StringPtrValue(flagutil.Ptr("prometheus"), &in.Driver), strings.Join(append(prefix, "driver"), "."), "")
	if in.Prometheus == nil {
		in.Prometheus = &PrometheusSpec{}
	}
	fs.AddFlagSet(in.Prometheus.FlagSet(append(prefix, "prometheus")...))
	if in.Otel == nil {
		in.Otel = &OTELSpec{}
	}
	fs.AddFlagSet(in.Otel.FlagSet(append(prefix, "otel")...))
	return fs
}

func (in *PrometheusSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("PrometheusSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(flagutil.Ptr("quay.io/prometheus/prometheus:latest"), &in.Image), strings.Join(append(prefix, "image"), "."), "")
	return fs
}

func (in *OTELSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("OTELSpec", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Wal == nil {
		in.Wal = &WALConfig{}
	}
	fs.AddFlagSet(in.Wal.FlagSet(append(prefix, "wal")...))
	fs.Var(flagutil.BoolPtrValue(nil, &in.HostMetrics), strings.Join(append(prefix, "host-metrics"), "."), "")
	return fs
}

func (in *WALConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("WALConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.BoolPtrValue(nil, &in.Enabled), strings.Join(append(prefix, "enabled"), "."), "")
	fs.Var(flagutil.IntPtrValue(nil, &in.BufferSize), strings.Join(append(prefix, "buffer-size"), "."), "")
	fs.Var(flagutil.DurationpbValue(nil, &in.TruncateFrequency), strings.Join(append(prefix, "truncate-frequency"), "."), "")
	return fs
}

func (in *NodeGetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("NodeGetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &v1.Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(append(prefix, "revision")...))
	return fs
}

func (in *NodeSetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("NodeSetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &v1.Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	if in.Spec == nil {
		in.Spec = &MetricsCapabilityConfig{}
	}
	fs.AddFlagSet(in.Spec.FlagSet(append(prefix, "spec")...))
	return fs
}

func (in *NodeResetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("NodeResetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &v1.Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	return fs
}

func (in *ConfigurationHistoryRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ConfigurationHistoryRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &v1.Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	fs.Var(flagutil.EnumValue(&in.Target), strings.Join(append(prefix, "target"), "."), "")
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(prefix...))
	fs.BoolVar(&in.IncludeValues, strings.Join(append(prefix, "include-values"), "."), true, "")
	return fs
}
